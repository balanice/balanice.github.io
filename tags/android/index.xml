<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Android on Balanice&#39;s Blog</title>
    <link>https://balanice.github.io/tags/android/</link>
    <description>Recent content in Android on Balanice&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 06 Jul 2022 08:09:37 +0800</lastBuildDate><atom:link href="https://balanice.github.io/tags/android/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>scrcpy 客户端源码阅读</title>
      <link>https://balanice.github.io/post/scrcpy-client-source/</link>
      <pubDate>Wed, 06 Jul 2022 08:09:37 +0800</pubDate>
      
      <guid>https://balanice.github.io/post/scrcpy-client-source/</guid>
      <description>scrcpy 是一款提供投屏和操作 Android 设备的开源软件, 无需 root. 其源码分为 client 和 server 两部分, client 位于 app/ 目录中, 由 C 实现, server 位于 server/ 目录, 由 Java 实现. 本文基于 scrcpy-1.17.
client 程序入口位于 main.c 的 main() 函数, 调用了 scrcpy() 函数:
int main(int argc, char *argv[]) { //... //... int res = scrcpy(&amp;amp;args.opts) ? 0 : 1; avformat_network_deinit(); // ignore failure return res; } scrcpy() scrcpy() 函数位于 scrcpy.c, 我们定位到这里看看这个函数做了什么:
bool scrcpy(const struct scrcpy_options *options) { if (!</description>
    </item>
    
    <item>
      <title>Android 证书固定(certificate pinning)及如何绕过它</title>
      <link>https://balanice.github.io/post/android_certificate_pinning/</link>
      <pubDate>Fri, 18 Feb 2022 08:12:37 +0800</pubDate>
      
      <guid>https://balanice.github.io/post/android_certificate_pinning/</guid>
      <description>如何配置固定证书 从 Android7.0 开始, Android 默认只信任 system 证书, 不再信任 user 及管理员安装的证书. 固定证书则更进一步, 将服务器证书信息存入到 app 中, 在访问后台接口时候, 如果发现后台证书与预置的证书不一致, 就会拒绝访问. 实现证书固定的方式有两种, Android 官方给定的和在代码中设置:
OkHttp设置 certificate pinning 如果不知道网站证书的 sha256 hash 值的话, 可以先填写一个其他网站的, 比如我这里用的就是 google 的, 这个值可以填一个错的, 但千万不能写一个空的, 如 &amp;ldquo;sha/AAA&amp;rdquo;, 否则会触发不了我们想要的效果
class PinningRequest { private var client: OkHttpClient? = null private val url = &amp;#34;https://api.github.com/api/users/balanice&amp;#34; private val tag = &amp;#34;PinningRequest&amp;#34; init { val pinning = CertificatePinner.Builder() .add(&amp;#34;api.github.com&amp;#34;, &amp;#34;sha256/7HIpactkIAq2Y49orFOOQKurWxmmSFZhBCoQYcRhJ3Y=&amp;#34;) .build() client = OkHttpClient.Builder().certificatePinner(pinning).build() } fun getDetails() { val request = Request.</description>
    </item>
    
    <item>
      <title>使用 minicap 搭建远程操作网站</title>
      <link>https://balanice.github.io/post/use-minicap-build-test-server/</link>
      <pubDate>Sat, 27 Mar 2021 08:12:37 +0800</pubDate>
      
      <guid>https://balanice.github.io/post/use-minicap-build-test-server/</guid>
      <description>技术选型 我们本次使用 minicap 获取手机屏幕内容, 使用 SpringBoot 实现网站服务, ddmlib 来对手机进行操作, WebSocket 传输图片数据, JavaScript + Html 实现前端界面.
实现 添加依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-websocket&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.android.tools.ddms&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;ddmlib&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;27.1.3&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 创建 WebSocket 服务端 使用 WebSocket 传输数据, 在连接上时候启动 minicap, 接受并解析 minicap 数据, 在检测到 WebSocket 关闭或发生错误时候关闭 minicap, 代码如下: @Component @ServerEndpoint(&amp;#34;/screen&amp;#34;) public class MiniWebSocket { private static final Logger logger = LoggerFactory.getLogger(MiniWebSocket.class); @OnOpen public void onOpen(Session session) { logger.info(&amp;#34;onOpen&amp;#34;); SpringContextUtil.getBean(DeviceService.class).startScreen(session); } @OnMessage public void onMessage(Session session, String message) { logger.</description>
    </item>
    
    <item>
      <title>minicap 使用</title>
      <link>https://balanice.github.io/post/minicap-usage/</link>
      <pubDate>Sun, 21 Feb 2021 08:12:37 +0800</pubDate>
      
      <guid>https://balanice.github.io/post/minicap-usage/</guid>
      <description>minicap 是什么 minicap 是为 Android 系统开发的一款快速输出手机界面的库, 不需要 root 权限. 通过它可以实现超快的截图, 实时显示手机界面. 通常用来开发投屏软件或者远程调试平台.
minicap 如何启动 参考官方文档
编译 下载 minicap 工程到本地 git submodule init git submodule update 使用 NDK 编译 minicap 编译需要使用到 NDK, 请先下载好新版 NDK, 并配置好环境变量, 然后使用下面命令编译:
ndk-build 编译成功后, 可执行文件生成在 ./libs 文件夹
启动 查询手机 cpu 架构: ABI=$(adb shell getprop ro.product.cpu.abi | tr -d &amp;#39;\r&amp;#39;) 将对应架构的二进制文件推入手机: adb push libs/$ABI/minicap /data/local/tmp/ 添加可执行权限 (部分手机需要): adb shell chmod 777 /data/local/tmp/minicap 推送 minicap.so 库. minicap.so 需要使用 AOSP 源码进行编译, minicap 已经预先编译好了, 我们可以直接拿来用 SDK=$(adb shell getprop ro.</description>
    </item>
    
    <item>
      <title>Android Tips</title>
      <link>https://balanice.github.io/post/android-tips/</link>
      <pubDate>Mon, 11 Jan 2021 08:12:37 +0800</pubDate>
      
      <guid>https://balanice.github.io/post/android-tips/</guid>
      <description>Android 部分小技巧 启动 Settings 下的 activity, 可以去 Settings 的 action 中查找对应 action 添加部分 System App 才能申请的权限时候, 忽略告警 tools:ignore=&amp;quot;Pretected Permissions&amp;quot;
Android 自动弹出软键盘： Window window = getWindow(); if (window != null) { window.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE); } 分享一个修复固定屏幕的 Bug 的一点经验： 设置 -&amp;gt; 锁屏、指纹、安全 -&amp;gt; 更多安全设置 -&amp;gt; 屏幕固定
现在可以通过最近任务固定屏幕，固定屏幕的意图是只允许用户在一个 Task 内使用手机，这个时候如果有点击事件触发了后台服务的逻辑，可能会出现 Bug
ActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE); if (am.getLockTaskModeState() != ActivityManager.LOCK_TASK_MODE_NONE) { // 当前处于固定屏幕模式下 } Android lazy load 问题 getWindow.getDecorView.post(new Runnable{ @override public void run() { new Handler().</description>
    </item>
    
    <item>
      <title>adb tips</title>
      <link>https://balanice.github.io/post/adb-tips/</link>
      <pubDate>Sun, 10 Jan 2021 08:12:37 +0800</pubDate>
      
      <guid>https://balanice.github.io/post/adb-tips/</guid>
      <description>参考资料: 命令行工具
adb shell am 发送广播 adb shell am boradcast -a [ACTION] 例如：adb shell am broadcast -a com.force.test.hello 获取Activity启动时间 adb shell am start -W [PACKAGE/.ACTIVITY] 例如:adb shell am start -W com.example/.MainActivity 发送 json 格式的参数, 使用引号包裹 adb shell 后面的语句, 将其当为参数传递 adb shell &amp;quot;am start service &#39;&amp;quot;&#39;{json}&#39;&amp;quot;&#39; -n xxx/.service&amp;quot; 打开设置主页面 adb shell am start com.android.settings/com.android.settings.Settings svc # 开启 WiFi adb shell svc wifi enable # 关闭 WiFi adb shell svn wifi disable # 开启手机数据 adb shell svc data enable # 关闭手机数据 adb shell svc data disable dumpsys 参考地址:dumpsys</description>
    </item>
    
  </channel>
</rss>
