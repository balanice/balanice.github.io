<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.101.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Balanice&#39;s Blog</title>
  <meta name="description" content="资深 Ctrl C &#43; Ctrl V 程序员" />

  
  <link type="text/css" rel="stylesheet" href="https://balanice.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://balanice.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://balanice.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://balanice.github.io/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="https://balanice.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Balanice's Blog" />
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://balanice.github.io/"><h1>Balanice&#39;s Blog</h1></a>
      <p class="lead">
       资深 Ctrl C &#43; Ctrl V 程序员 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://balanice.github.io/">Home</a> </li>
        <li><a href="https://github.com/balanice/"> balanice </a></li>
      </ul>
    </nav>

    <p>tokuu@outlook.com</p>
  </div>
</aside>

    <main class="content container">
    <div class="posts">
<article class="post">
  <h1 class="post-title">
    <a href="https://balanice.github.io/post/scrcpy-server-source/">Scrcpy Server 源码阅读</a>
  </h1>
  <time datetime="2022-07-11T13:02:46&#43;0800" class="post-date">Mon, Jul 11, 2022</time>
  之前的文章查看了 scrcpy client 端代码, 这里查看 server 端代码, 同样基于 scrcpy-1.17.
程序入口 server 位于 sercver/ 目录, 程序入口为 Server.java 的 main() 方法, 在这里调用了 scrcpy() 方法, 看看 scrcpy() 方法做了什么:
private static void scrcpy(Options options) throws IOException { // ... // ... // 是否为 adb forward boolean tunnelForward = options.isTunnelForward(); // 创建与主机通信的 server 或 socket, 拿到 videoSocket 和 controlSocket try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) { // 编码器, 内部由 MediaCodec 实现 ScreenEncoder screenEncoder = new ScreenEncoder(options.
  
  <div class="read-more-link">
    <a href="/post/scrcpy-server-source/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://balanice.github.io/post/scrcpy-client-source/">scrcpy 客户端源码阅读</a>
  </h1>
  <time datetime="2022-07-06T08:09:37&#43;0800" class="post-date">Wed, Jul 6, 2022</time>
  scrcpy 是一款提供投屏和操作 Android 设备的开源软件, 无需 root. 其源码分为 client 和 server 两部分, client 位于 app/ 目录中, 由 C 实现, server 位于 server/ 目录, 由 Java 实现. 本文基于 scrcpy-1.17.
client 程序入口位于 main.c 的 main() 函数, 调用了 scrcpy() 函数:
int main(int argc, char *argv[]) { //... //... int res = scrcpy(&amp;args.opts) ? 0 : 1; avformat_network_deinit(); // ignore failure return res; } scrcpy() scrcpy() 函数位于 scrcpy.c, 我们定位到这里看看这个函数做了什么:
bool scrcpy(const struct scrcpy_options *options) { if (!
  
  <div class="read-more-link">
    <a href="/post/scrcpy-client-source/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://balanice.github.io/post/arch-tips/">ArchLinux Tips</a>
  </h1>
  <time datetime="2022-07-02T08:12:37&#43;0800" class="post-date">Sat, Jul 2, 2022</time>
  AUR (Arch User Repository) 使用 参考 AUR
使用 git 拉取目标仓库: git clone xxx.git; cd 到相应目录, 执行 makepkg; 执行 pacman -U xxx.zst 安装; 可以使用 git clean -dfx 清除历史文件; 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://balanice.github.io/post/git-tips/">Git Tips</a>
  </h1>
  <time datetime="2022-07-02T08:09:37&#43;0800" class="post-date">Sat, Jul 2, 2022</time>
  git 删除未跟踪文件 git clean -dfx
git 关联 remote repository git remote add origin xxx.git
git add submodule git submodule add [repository] [localpath]
查看已关联的 repository git remote -v
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://balanice.github.io/post/android_certificate_pinning/">Android 证书固定(certificate pinning)及如何绕过它</a>
  </h1>
  <time datetime="2022-02-18T08:12:37&#43;0800" class="post-date">Fri, Feb 18, 2022</time>
  如何配置固定证书 从 Android7.0 开始, Android 默认只信任 system 证书, 不再信任 user 及管理员安装的证书. 固定证书则更进一步, 将服务器证书信息存入到 app 中, 在访问后台接口时候, 如果发现后台证书与预置的证书不一致, 就会拒绝访问. 实现证书固定的方式有两种, Android 官方给定的和在代码中设置:
OkHttp设置 certificate pinning 如果不知道网站证书的 sha256 hash 值的话, 可以先填写一个其他网站的, 比如我这里用的就是 google 的, 这个值可以填一个错的, 但千万不能写一个空的, 如 &ldquo;sha/AAA&rdquo;, 否则会触发不了我们想要的效果
class PinningRequest { private var client: OkHttpClient? = null private val url = &#34;https://api.github.com/api/users/balanice&#34; private val tag = &#34;PinningRequest&#34; init { val pinning = CertificatePinner.Builder() .add(&#34;api.github.com&#34;, &#34;sha256/7HIpactkIAq2Y49orFOOQKurWxmmSFZhBCoQYcRhJ3Y=&#34;) .build() client = OkHttpClient.Builder().certificatePinner(pinning).build() } fun getDetails() { val request = Request.
  
  <div class="read-more-link">
    <a href="/post/android_certificate_pinning/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://balanice.github.io/post/use-minicap-build-test-server/">使用 minicap 搭建远程操作网站</a>
  </h1>
  <time datetime="2021-03-27T08:12:37&#43;0800" class="post-date">Sat, Mar 27, 2021</time>
  技术选型 我们本次使用 minicap 获取手机屏幕内容, 使用 SpringBoot 实现网站服务, ddmlib 来对手机进行操作, WebSocket 传输图片数据, JavaScript + Html 实现前端界面.
实现 添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.android.tools.ddms&lt;/groupId&gt; &lt;artifactId&gt;ddmlib&lt;/artifactId&gt; &lt;version&gt;27.1.3&lt;/version&gt; &lt;/dependency&gt; 创建 WebSocket 服务端 使用 WebSocket 传输数据, 在连接上时候启动 minicap, 接受并解析 minicap 数据, 在检测到 WebSocket 关闭或发生错误时候关闭 minicap, 代码如下: @Component @ServerEndpoint(&#34;/screen&#34;) public class MiniWebSocket { private static final Logger logger = LoggerFactory.getLogger(MiniWebSocket.class); @OnOpen public void onOpen(Session session) { logger.info(&#34;onOpen&#34;); SpringContextUtil.getBean(DeviceService.class).startScreen(session); } @OnMessage public void onMessage(Session session, String message) { logger.
  
  <div class="read-more-link">
    <a href="/post/use-minicap-build-test-server/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://balanice.github.io/post/minicap-usage/">minicap 使用</a>
  </h1>
  <time datetime="2021-02-21T08:12:37&#43;0800" class="post-date">Sun, Feb 21, 2021</time>
  minicap 是什么 minicap 是为 Android 系统开发的一款快速输出手机界面的库, 不需要 root 权限. 通过它可以实现超快的截图, 实时显示手机界面. 通常用来开发投屏软件或者远程调试平台.
minicap 如何启动 参考官方文档
编译 下载 minicap 工程到本地 git submodule init git submodule update 使用 NDK 编译 minicap 编译需要使用到 NDK, 请先下载好新版 NDK, 并配置好环境变量, 然后使用下面命令编译:
ndk-build 编译成功后, 可执行文件生成在 ./libs 文件夹
启动 查询手机 cpu 架构: ABI=$(adb shell getprop ro.product.cpu.abi | tr -d &#39;\r&#39;) 将对应架构的二进制文件推入手机: adb push libs/$ABI/minicap /data/local/tmp/ 添加可执行权限 (部分手机需要): adb shell chmod 777 /data/local/tmp/minicap 推送 minicap.so 库. minicap.so 需要使用 AOSP 源码进行编译, minicap 已经预先编译好了, 我们可以直接拿来用 SDK=$(adb shell getprop ro.
  
  <div class="read-more-link">
    <a href="/post/minicap-usage/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://balanice.github.io/post/slf4j-and-logback/">slf4j &#43; logback 记录日志</a>
  </h1>
  <time datetime="2021-01-24T08:12:37&#43;0800" class="post-date">Sun, Jan 24, 2021</time>
  如何使用 Springboot 项目无需安装， 框架中已经集成了 slf4j 和 logback. 创建 src/main/resource/logback.xml 文件， 文件配置如下：
&lt;configuration&gt; &lt;property name=&#34;LOG_HOME&#34; value=&#34;logs&#34;/&gt; &lt;appender name=&#34;STDOUT&#34; class=&#34;ch.qos.logback.core.ConsoleAppender&#34;&gt; &lt;encoder&gt; &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} %line - %msg%n&lt;/pattern&gt; &lt;charset&gt;utf-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=&#34;FILE&#34; class=&#34;ch.qos.logback.core.rolling.RollingFileAppender&#34;&gt; &lt;file&gt;${LOG_HOME}/demo.log&lt;/file&gt; &lt;encoder class=&#34;ch.qos.logback.classic.encoder.PatternLayoutEncoder&#34;&gt; &lt;pattern&gt;&#34;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} %line - %msg%n&#34;&lt;/pattern&gt; &lt;charset&gt;utf-8&lt;/charset&gt; &lt;/encoder&gt; &lt;rollingPolicy class=&#34;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&#34;&gt; &lt;fileNamePattern&gt;log/demo-%d{yyyy-MM-dd}_%i.log&lt;/fileNamePattern&gt; &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;root level=&#34;debug&#34;&gt; &lt;appender-ref ref=&#34;STDOUT&#34; /&gt; &lt;appender-ref ref=&#34;FILE&#34; /&gt; &lt;/root&gt; &lt;/configuration&gt; 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://balanice.github.io/post/use-java-parse-mjpeg/">使用 Java 解析 MJPEG 为 JPG 数组</a>
  </h1>
  <time datetime="2021-01-19T08:12:37&#43;0800" class="post-date">Tue, Jan 19, 2021</time>
  MJPEG 是什么 Motion JPEG (M-JPEG 或 MJPEG, Motion Joint Photographic Experts Group, FourCC:MJPG) 是一种影像压缩格式，其中每一帧图像都分别使用 JPEG 编码. MJPEG 常用在数码相机和摄像头之类的图像采集设备上, 非线性剪辑系统也常采用这种格式, 可精确到帧编辑和多层图像处理，把运动的视频序列作为连续的静止图像来处理，这种压缩方式单独完整地压缩每一帧，在编辑过程中可随机存储每一帧，可进行精确到帧的编辑.
QuickTime 播放器和包括 Mozilia Firefox, Google Chrome, Safari 在内许多网页浏览器原生支持 M-JPEG.
如果只是想在前端展示, 直接用 img 标签即可, 例如你有一个地址为 http://localhost:8964/apple.mjpeg 的视频流:
&lt;img src=&#34;http://localhost:8964/apple.mjpeg&#34; width=&#34;1080&#34; height=&#34;1920&#34;&gt; 如何解析 通过上面介绍我们知道了 MJPEG 是由完整的 JPEG 图片组成的视频流, 那么想解析 MJPEG 就要先了解一下 jpg 格式. 找一张 jpg 图片, 使用 Bless Hex Editor 或者 UltraEdit 打开
从上图可以看到 jpg 图片的开头是 FF D8
下拉到结尾, 可以看到 jpg 图片以 FF D9 结尾.
  
  <div class="read-more-link">
    <a href="/post/use-java-parse-mjpeg/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://balanice.github.io/post/vim-from-start-to-abort/">Vim 从入门到放弃</a>
  </h1>
  <time datetime="2021-01-17T08:12:37&#43;0800" class="post-date">Sun, Jan 17, 2021</time>
  Vim 是什么 Vim - Vi improved, 是 Vi 这个命令行编辑器的优化版本. 它的操作可以不依赖鼠标, 实现文本的快速编辑, 打开大文件毫无压力.
Vim 怎么用 Vim 基础教程 Vim 自带教程, 在命令行中输入 vimtutor 即可进入, 完成这个教程以后就能掌握 Vim 的基本操作.
vimrc 配置 学习完成 Vim 的基础操作之后, 就必须学习一下 Vim 的配置, 通过对 Vim 的配置, 可以增强 Vim 的使用体验.
Vim 的配置文件为 .vimrc, Linux 系统位于 ~/.vimrc, Windows 路径为 C:\Users\username\_vimrc, 如果该路径下没有可以手动创建, 常用配置如下:
&#34;显示行号 set number &#34;代码高亮 syntax on &#34;启用鼠标 set mouse-=a &#34;自动缩进 set expandtab set tabstop=4 set softtabstop=4 set shiftwidth=4 set backspace=2 set textwidth=79 set autoindent set smartindent	set nocompatible &#34;使用vim自己的键盘 &#34;自动补全括号 :inoremap ( ()&lt;esc&gt;i :inoremap { {}&lt;esc&gt;i :inoremap [ []&lt;esc&gt;i :inoremap &#34; &#34;&#34;&lt;esc&gt;i :inoremap &#39; &#39;&#39;&lt;esc&gt;i &#34;支持中文 set fileencodings=utf-8,gbk set ambiwidth=double &#34;补全函数 ctrl + x ctrl + o &#34;使用pydiction补全python代码 filetype on filetype plugin on filetype indent on autocmd FileType python set omnifunc=pythoncomplete#Complete let g:pydiction_location=&#34;~/.
  
  <div class="read-more-link">
    <a href="/post/vim-from-start-to-abort/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://balanice.github.io/post/android-tips/">Android Tips</a>
  </h1>
  <time datetime="2021-01-11T08:12:37&#43;0800" class="post-date">Mon, Jan 11, 2021</time>
  Android 部分小技巧 启动 Settings 下的 activity, 可以去 Settings 的 action 中查找对应 action 添加部分 System App 才能申请的权限时候, 忽略告警 tools:ignore=&quot;Pretected Permissions&quot;
Android 自动弹出软键盘： Window window = getWindow(); if (window != null) { window.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE); } 分享一个修复固定屏幕的 Bug 的一点经验： 设置 -&gt; 锁屏、指纹、安全 -&gt; 更多安全设置 -&gt; 屏幕固定
现在可以通过最近任务固定屏幕，固定屏幕的意图是只允许用户在一个 Task 内使用手机，这个时候如果有点击事件触发了后台服务的逻辑，可能会出现 Bug
ActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE); if (am.getLockTaskModeState() != ActivityManager.LOCK_TASK_MODE_NONE) { // 当前处于固定屏幕模式下 } Android lazy load 问题 getWindow.getDecorView.post(new Runnable{ @override public void run() { new Handler().
  
  <div class="read-more-link">
    <a href="/post/android-tips/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://balanice.github.io/post/adb-tips/">adb tips</a>
  </h1>
  <time datetime="2021-01-10T08:12:37&#43;0800" class="post-date">Sun, Jan 10, 2021</time>
  参考资料: 命令行工具
adb shell am 发送广播 adb shell am boradcast -a [ACTION] 例如：adb shell am broadcast -a com.force.test.hello 获取Activity启动时间 adb shell am start -W [PACKAGE/.ACTIVITY] 例如:adb shell am start -W com.example/.MainActivity 发送 json 格式的参数, 使用引号包裹 adb shell 后面的语句, 将其当为参数传递 adb shell &quot;am start service '&quot;'{json}'&quot;' -n xxx/.service&quot; 打开设置主页面 adb shell am start com.android.settings/com.android.settings.Settings svc # 开启 WiFi adb shell svc wifi enable # 关闭 WiFi adb shell svn wifi disable # 开启手机数据 adb shell svc data enable # 关闭手机数据 adb shell svc data disable dumpsys 参考地址:dumpsys
  
  <div class="read-more-link">
    <a href="/post/adb-tips/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://balanice.github.io/posts/notification/">Notification 的使用</a>
  </h1>
  <time datetime="2018-01-26T08:55:17&#43;0800" class="post-date">Fri, Jan 26, 2018</time>
  Android 8.0 新特性 Android 8.0重新设计了通知，以便为管理通知行为和设置提供更轻松和更统一的方式。这些变更包括：
通知渠道 Android 8.0 引入了通知渠道特性，将应用的通知进行分门别类，用户可以针对不同的通知类别单独设置通知优先级别和提醒方式。用户界面将通知渠道称之为通知类别。
1.创建通知渠道 NotificationChannel channel = new NotificationChannel(channelId， name， importance); channel.setShowBadge(canShowBadge); channel.enableVibration(vibration); channel.setSound(sound， null); channel.enableLights(lights); channel.setBypassDnd(dnd); channel.setLockscreenVisibility(lockScreen); getNotificationManager(context).createNotificationChannel(channel); 从方法上可以看出，渠道将之前由Notification.Builder设置的部分方法转移到NotificationChannel中了.
2.读取通知渠道 用户可以设置通知渠道的行为，包括震动和声音。可以通过如下方法来读取用户对通知渠道的设置:
通过getNotificationChannel()获取单个通知渠道; 通过getNotificationChannels()方法获取应用所有的通知渠道。 通过上面的方法获取到NotificationChannel之后，可以通过getVibrationPattern()，getSound()等方法获取到用户当前的设置。要查看当前通知渠道是否被禁用，可以通过getImportance()方法，如果被禁用，这个方法会返回IMPORTANCE_NONE。 3. 更新通知渠道 通知渠道创建之后，用户将负责其设置和行为。此时，可以通过调用createNotificationChannel()方法，然后再次将通知渠道提交到通知管理器来对已存在的通知渠道更名，或者更新它的内容。 通过下面的代码，你可以通过以创建新的Activity的方式跳转到通知渠道的设置界面。该方法需要这个渠道的ID和应用的包名
Intent intent = new Intent(Settings.ACTION_CHANNEL_NOTIFICATION_SETTINGS); intent.putExtra(Settings.EXTRA_CHANNEL_ID， mChannel.getId()); intent.putExtra(Settings.EXTRA_APP_PACKAGE， getPackageName()); startActivity(intent); 4. 删除通知渠道 可以通过调用deleteNotificationChannel()方法来删除通知渠道:
NotificationManager mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE); // The id of the channel. String id = &#34;my_channel_01&#34;; mNotificationManager.deleteNotificationChannel(id); 注意: 作为一种垃圾邮件预防机制，通知设置界面会显示被删除的渠道数量。
通知标志 Android 8.0 开始，应用可以在启动器图标上显示通知圆点来提示用户，但这个圆点角标和 iOS 上那个有所不同——它仅提示用户该应用有通知，不会显示具体的通知数量。 通知标志显示用户未操作或者关闭的,与一个或者多个通知渠道管理的通知.
  
  <div class="read-more-link">
    <a href="/posts/notification/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://balanice.github.io/readme/">README</a>
  </h1>
  <time datetime="2016-04-23T08:53:21&#43;0800" class="post-date">Sat, Apr 23, 2016</time>
  Main Anroid and Java, know some Python and C++.
  
</article>
</div>
    </main>

    
      
    
  </body>
</html>
