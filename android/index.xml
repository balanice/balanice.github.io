<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Androids on Balanice&#39;s Blog</title>
    <link>https://balanice.github.io/android/</link>
    <description>Recent content in Androids on Balanice&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 22 Jul 2022 08:39:54 +0800</lastBuildDate><atom:link href="https://balanice.github.io/android/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Android 开机启动流程</title>
      <link>https://balanice.github.io/android/android-power-on/</link>
      <pubDate>Fri, 22 Jul 2022 08:39:54 +0800</pubDate>
      
      <guid>https://balanice.github.io/android/android-power-on/</guid>
      <description>本文代码基于 Android 12 Android 系统底层基于 Linux 内核, 其启动过程与 Linux 系统类似, 在按下电源键以后, 首先启动的是引导程序 BootLoader, Linux 上一般是 GRUB. 我们平时刷机一般都是需要先解锁 BootLoader, 安装第三方 Recovery, 如 TWRP, 然后才能刷机, 当然厂商有更便捷的刷机方式, 不过普通人一般接触不到, 此处不做讨论.
BootLoader 为什么要加锁? 当然是出于安全原因, 为了保护手机中的数据. 比如有人捡到一台手机, 这个手机有锁屏密码, 但是 BootLoader 未加锁, 那么别人就可以轻易通过刷机的方式绕过锁屏密码, 类似于给电脑重装系统. BootLoader 做了什么? BootLoader 是在操作系统运行之前执行的一段程序, 通过这个程序来初始化硬件设备, 建立内存空间的映射表, 从而建立适当的系统软硬件环境, 为最终调用系统内核做好准备.
init Linux 内核启动 Android 的 init 进程, 入口代码位于 /system/core/init/main.cpp 的 main() 函数:
int main(int argc, char** argv) { #if __has_feature(address_sanitizer) __asan_set_error_report_callback(AsanReportCallback); #endif // Boost prio which will be restored later setpriority(PRIO_PROCESS, 0, -20); if (!</description>
    </item>
    
    <item>
      <title>Android 四大组件之 Activity</title>
      <link>https://balanice.github.io/android/activity/</link>
      <pubDate>Sat, 05 May 2018 10:22:32 +0800</pubDate>
      
      <guid>https://balanice.github.io/android/activity/</guid>
      <description>Activity 是一个应用组件, 用户可与其提供的屏幕进行交互, 以执行拨打电话, 拍摄照片, 发送电子邮件或查看地图等操作. 每个 Activity 都会获得一个用于绘制其用户界面的窗口. 通常会充满屏幕, 但也可以 小于屏幕并浮动在其他窗口之上.
Activity 生命周期 onCreate() 表示 Activity 正在被创建, 这是生命周期的第一个方法. 在这个方法中, 我们可以做一些初始化工作, 比如调用 setContentView() 去加载界面资源, 初始化 Activity 所需数据等.
onRestart() 表示 Activity 正在重新启动. 一般情况下, 当当前 Activity 从不可见重新变为可见状态时, onRestart() 会被调用. 这种情况一般是用户行为所导致的, 比如用户按 Home 键切换到桌面状态或者用户打开了一个新的 Activity, 这时当前的 Activity 就会暂停, 也就是 onPause() 和 onStop() 执行了, 接着用户又回到了这个 Activity, 就会出现这种情况.
onStart() 表示 Activity 正在被启动, 即将开始, 这时 Activity 已经可见了, 但是还没有出现在前台, 还无法和用户交互. 这时其实可以理解为 Activity 已经显示出来了, 但是我们还看不到.
onResume() 表示 Activity 已经可见了, 并且出现在活动前台开始活动.</description>
    </item>
    
    <item>
      <title>Content_provider</title>
      <link>https://balanice.github.io/android/content_provider/</link>
      <pubDate>Thu, 19 Apr 2018 08:18:27 +0800</pubDate>
      
      <guid>https://balanice.github.io/android/content_provider/</guid>
      <description>ContentProvider 是构建 Android 应用的重要组件之一, 它封装数据并通过简单的 ContentResolver 接口向应用提供数据. 仅在需要在多个应用间共享数据时候才需要实现 ContentProvider, 例如联系人应用. ContentProvider 是一种标准接口, 能提供很好的抽象, 可以在修改修改应用数据存储实现的同时不影响访问数据的其它应用. 例如, 可以将 SQLite 数据库换成其它存储空间 ContentProvider 是应用程序之间共享数据的接口. 使用的时候首先自定义一个继承 ContentProvider 的子类, 然后覆写 query, insert, update, delete 等方法. 因为是四大组件之一, 因此必须在 AndroidManifest 文件中进行注册, 将自己的数据以 URI 的方式共享出去, 第三方应用可以通过ContentResolver 来访问.
底层也是由 binder 实现
URI介绍 每一个 ContentProvider 都有一个公共的 URI, 只能通过访问该 URI 来访问数据 Android提供的 ContentProvider 都存放在 android.provider 包中, 将其分为A, B, C, D四个部分:
A: 标准前缀, 用来说明一个 ContentProvider 控制这些数据, 无法改变: &amp;ldquo;content://&amp;rdquo; B: URI 的标识, 用于唯一标示这个 ContentProvider, 外部调用者可以通过这个标识来找到它.</description>
    </item>
    
  </channel>
</rss>
